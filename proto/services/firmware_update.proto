syntax = "proto3";

package ringbahn.v1;

// Firmware update service request wrapper
message FirmwareUpdateRequest {
  oneof command {
    ESP32OTARequest esp32_ota = 1; // ESP32 OTA update commands (Host PC -> ESP32 over UART);
    CANBootloaderRequest can_bootloader = 2; // CAN bootloader commands (Host PC -> ESP32 -> End Device over CAN);
  }
}

// ===== ESP32 OTA Update Protocol (Host PC -> ESP32 Bridge) =====

// ESP32 OTA update commands
message ESP32OTARequest {
  oneof command {
    BeginOTARequest begin_ota = 1; // Begin OTA update (select next partition);
    WriteOTADataRequest write_data = 2; // Write firmware data chunk;
    EndOTARequest end_ota = 3; // Complete OTA update and validate;
    AbortOTARequest abort_ota = 4; // Cancel OTA update;
    SetBootPartitionRequest set_boot = 5; // Set boot partition and reboot;
  }
}

// Begin ESP32 OTA update - selects next available partition
message BeginOTARequest {
  uint32 image_size = 1; // Total firmware image size in bytes;
  uint32 firmware_version = 2; // Firmware version number;
}

// Write firmware data chunk to ESP32 OTA partition
message WriteOTADataRequest {
  bytes data = 1; // Firmware data chunk (max 4096 bytes);
  uint32 offset = 2; // Byte offset in firmware image;
}

// Complete ESP32 OTA update - validates and marks partition
message EndOTARequest {
  bool validate_sha256 = 1; // Perform SHA256 validation;
}

// Abort ESP32 OTA update - erases partition
message AbortOTARequest {
  // Empty - no parameters needed;
}

// Set boot partition and reboot ESP32
message SetBootPartitionRequest {
  // Empty - reboots to newly flashed partition;
}

// ===== CAN Bootloader Protocol (ESP32 forwards to End Devices) =====

// CAN bootloader commands forwarded by ESP32 to end devices
message CANBootloaderRequest {
  uint32 board_id = 1; // Target board ID on CAN bus (0-255);
  oneof command {
    CANPingRequest ping = 2; // Ping bootloader (responds regardless of board_id);
    CANWritePageBufferRequest write_page_buffer = 3; // Write data to page buffer in RAM;
    CANWritePageRequest write_page = 4; // Flash page buffer to flash memory;
    CANWriteCRCRequest write_crc = 5; // Store entire firmware CRC;
    CANSetIDRequest set_id = 6; // Change board ID;
    CANResetToBootloaderRequest reset_to_bootloader = 7; // Send 0xB0 CAN frame to reset device to bootloader;
  }
}

// Ping CAN bootloader (all boards respond regardless of ID)
message CANPingRequest {
  // Empty - used to verify bootloader is running;
}

// Write 4 bytes to page buffer at specified offset
message CANWritePageBufferRequest {
  uint32 offset = 1; // Offset into page buffer (0-1023 for 1KB page);
  uint32 data = 2; // 4 bytes of data to write;
}

// Write page buffer to flash at specified page number
message CANWritePageRequest {
  uint32 page_number = 1; // Flash page number (0 to PAGE_COUNT-1);
  uint32 page_crc = 2; // CRC32 of page buffer - must match or flash is skipped;
}

// Store firmware CRC after all pages written
message CANWriteCRCRequest {
  uint32 page_count = 1; // Number of pages the firmware uses;
  uint32 firmware_crc = 2; // CRC32 of entire firmware - must match flash or update fails;
}

// Change the board ID of a CAN device
message CANSetIDRequest {
  uint32 new_id = 1; // New board ID (0-255);
}

// Reset end device to bootloader mode (sends 0xB0 CAN frame)
message CANResetToBootloaderRequest {
  // Empty - triggers application to reset into bootloader;
}

// Response to firmware update operations
message FirmwareUpdateResponse {
  bool success = 1; // Operation completed successfully;
  int32 error_code = 2; // Error code if success=false;
  oneof response_data {
    ESP32OTAResponse esp32_ota = 3; // ESP32 OTA response;
    CANBootloaderResponse can_bootloader = 4; // CAN bootloader response;
  }
}

// ESP32 OTA update response
message ESP32OTAResponse {
  uint32 bytes_written = 1; // Total bytes written to OTA partition;
  uint32 free_space = 2; // Available space in OTA partition;
  bytes sha256_hash = 3; // SHA256 hash of written image (32 bytes);
  uint32 next_offset = 4; // Next expected write offset;
}

// CAN bootloader response
message CANBootloaderResponse {
  uint32 board_id = 1; // Board ID that responded (0-255);
  uint32 response_data = 2; // Response data (new ID for set_id command);
  bool bootloader_active = 3; // True if bootloader is running on device;
}
