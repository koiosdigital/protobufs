syntax = "proto3";

package ringbahn.v1;

import "devices/device_common.proto";

// Top-level VFD device command message
message VFDDeviceCommand {
  oneof command {
    // Common commands
    SystemInfoRequest system_info = 1; // Response: SystemInfoResponse
    HeartbeatRequest heartbeat = 2; // Response: HeartbeatResponse
    
    // VFD-specific commands
    SetFailSafeRequest set_fail_safe = 10; // Response: AcknowledgeResponse
    SetDriveModeRequest set_drive_mode = 11; // Response: AcknowledgeResponse
    SetFrequencyRequest set_frequency = 12; // Response: AcknowledgeResponse
    ClearAlarmRequest clear_alarm = 13; // Response: AcknowledgeResponse
    VFDGetStateRequest get_state = 14; // Response: VFDState
  }
}

// ===== VFD-Specific Commands =====

// Response: VFDState
message VFDGetStateRequest {}

// VFD drive mode enumeration
enum VFDDriveMode {
  DRIVE_MODE_UNSPECIFIED = 0;
  DRIVE_MODE_STOP = 1;
  DRIVE_MODE_FORWARD = 2;
  DRIVE_MODE_REVERSE = 3;
}

// VFD fail-safe mode enumeration
enum VFDFailSafeMode {
  FAIL_SAFE_MODE_UNSPECIFIED = 0;
  FAIL_SAFE_MODE_RAMP_DOWN = 1;
  FAIL_SAFE_MODE_E_STOP = 2;
  FAIL_SAFE_MODE_NONE = 3;
}

// Complete VFD device state
message VFDState {

  int64 timestamp_ms = 1; // When state was captured (milliseconds since epoch);
  float frequency_hz = 2;
  float power_w = 3;
  float current_a = 4;
  float voltage_v = 5;
  VFDDriveMode drive_mode = 6;
  VFDFailSafeMode fail_safe_mode = 7;
  int32 alarm_code = 8;
  float min_frequency_hz = 9;
  float max_frequency_hz = 10;
}

// Response: AcknowledgeResponse
message SetFailSafeRequest {
  VFDFailSafeMode mode = 1;
}

// Response: AcknowledgeResponse
message SetDriveModeRequest {
  VFDDriveMode mode = 1;
}

// Response: AcknowledgeResponse
message SetFrequencyRequest {
  float frequency_hz = 1;
}

// Response: AcknowledgeResponse
message ClearAlarmRequest {
  // Empty - clears current alarm
}
